---
title: vite的原理
---


##### 1. 开发环境：基于原生 ESM 的按需编译
Vite 在开发环境下利用浏览器原生支持的 ESM 特性，无需打包整个应用，而是直接按需编译和提供源码。

##### 关键机制：
* **原生 ESM 加载：**
    * 浏览器直接通过 **`<script type="module">`** 加载入口文件（如 main.js），并依赖 import/export 语法按需请求依赖模块。
    * 避免了传统打包工具（如 Webpack）在开发时打包整个应用的性能瓶颈。
* **快速启动：**
    * 启动时仅需启动一个轻量级开发服务器，无需等待打包，实现毫秒级启动。
* **按需编译：**
    * 当浏览器请求某个文件时，Vite 实时编译该文件（如 .vue、.ts 或 .scss），并将结果返回给浏览器。
    * 编译使用 esbuild（Go 语言编写，比 JavaScript 编译器快 10-100 倍）进行预处理（如 TS 转 JS）。
* **依赖预构建：**
    * 首次启动时，Vite 使用 esbuild 将第三方依赖（如 lodash）预构建为 ESM 格式，并缓存到 node_modules/.vite 中。
    * 解决 CommonJS 依赖的 ESM 兼容性问题，同时将多个小文件合并为大文件以减少 HTTP 请求。
* **HMR（热更新）：**
    * 利用 ESM 的模块边界特性，直接替换更新的模块，无需重新加载页面或重建依赖图，速度极快。

##### 示例流程：
1. 浏览器请求 main.js。
2. Vite 返回 main.js，其中包含 import { Component } from './Component.vue'。
3. 浏览器解析到 import，向服务器请求 Component.vue。
4. Vite 实时编译 Component.vue 为 JS 和 CSS，返回给浏览器。

##### 2. 生产环境：基于 Rollup 的打包优化
在生产环境下，Vite 使用 Rollup 进行全量打包，以获得最佳性能。

##### 关键机制：
* **Tree Shaking：** 移除未使用的代码。
* **代码分割：** 按需加载动态导入的模块。
* **静态资源处理：** 优化文件名哈希、体积压缩等。
* **ESbuild 辅助：** 在部分环节（如代码压缩）使用 esbuild 提速。
  
##### 3. 核心优势
* **极速启动：** 开发时跳过打包，按需编译。
* **高效热更新：** 仅更新变动的模块，不受项目规模影响。
* **开箱即用：** 支持 TS、JSX、CSS 预处理器等，无需额外配置。
* **双模式统一：** 开发与生产环境行为一致（均基于 ESM）。

##### 4. 与传统工具（如 Webpack）的对比
| 特性         | Vite               | Webpack                |
| ------------ | ------------------ | ---------------------- |
| 开发启动速度 | 极快（按需编译）   | 慢（全量打包）         |
| HMR 速度     | 快（模块级更新）   | 较慢（依赖依赖图重建） |
| 生产打包     | Rollup（功能完备） | 自建打包流程           |
| 复杂度       | 配置简单           | 配置复杂               |

##### 5. 技术栈依赖
* **ESM：** 浏览器原生模块化支持。
* **esbuild：** 极速的编译/压缩工具（Go 语言）。
* **Rollup：** 高效的生产打包工具。

##### 总结
Vite 通过 开发环境原生 ESM + 按需编译 和 生产环境 Rollup 打包 的组合，在开发者体验和性能之间取得了平衡。其核心思想是 “利用浏览器原生能力，减少不必要的打包”，尤其适合现代前端项目。
